#!/usr/bin/env node
/**
 * React Navigation â†’ Mermaid generator (split-safe)
 * - Works with ESM + glob@10
 * - Raises Mermaid edge limit via init block
 * - Dedupes edges
 * - Splits into multiple .mmd files if edges exceed a threshold
 */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { glob } from 'glob';
import { parse } from '@babel/parser';
import traverseModule from '@babel/traverse';
const traverse = traverseModule.default;

// ---------- CLI args ----------
const SRC_GLOB = process.argv[2] || 'src/**/*.{js,jsx,ts,tsx}';
const OUT_DIR = process.argv[3] || 'docs';
const BASENAME = process.argv[4] || 'nav_graph';
const EDGE_LIMIT_PER_FILE = Number(process.argv[5] || 900); // edges per output file
const MAX_EDGES_INIT = Number(process.argv[6] || 4000);     // Mermaid init maxEdges

// ---------- Utils ----------
const ensureDir = (p) => fs.mkdirSync(p, { recursive: true });
const writeText = (p, s) => fs.writeFileSync(p, s, 'utf8');

function attrValueString(attr) {
  if (!attr || !attr.value) return null;
  if (attr.value.type === 'StringLiteral') return attr.value.value;
  if (attr.value.type === 'JSXExpressionContainer') {
    const expr = attr.value.expression;
    if (!expr) return null;
    if (expr.type === 'StringLiteral') return expr.value;
    if (expr.type === 'Identifier') return expr.name;
    if (expr.type === 'MemberExpression' && expr.property?.name) return expr.property.name;
  }
  return null;
}
function getJSXName(node) {
  if (!node) return null;
  if (node.type === 'JSXIdentifier') return node.name;
  if (node.type === 'JSXMemberExpression') {
    const l = getJSXName(node.object);
    const r = getJSXName(node.property);
    return l && r ? `${l}.${r}` : null;
  }
  return null;
}
function firstAttr(node, names) {
  for (const a of node.openingElement.attributes || []) {
    if (a.type === 'JSXAttribute' && names.includes(a.name.name)) return a;
  }
  return null;
}
function sanitizeId(s) {
  return String(s).replace(/[^a-zA-Z0-9_]/g, '_');
}

// ---------- Data model ----------
const navigatorFactoryNames = new Set([
  'createNativeStackNavigator',
  'createStackNavigator',
  'createBottomTabNavigator',
  'createMaterialTopTabNavigator',
  'createDrawerNavigator',
]);

const project = {
  navigators: new Map(), // navVar -> { type, screens:Set<string>, file }
  edges: new Set(),      // "From-->To"
};

function upsertNavigator(name, type, file) {
  if (!project.navigators.has(name)) {
    project.navigators.set(name, { type, screens: new Set(), file });
  } else {
    const obj = project.navigators.get(name);
    if (!obj.type && type) obj.type = type;
    if (!obj.file) obj.file = file;
  }
}
function addScreen(nav, screen) {
  if (!nav || !screen) return;
  upsertNavigator(nav);
  project.navigators.get(nav).screens.add(screen);
}
function addEdge(from, to) {
  if (!from || !to || from === to) return;
  project.edges.add(`${from}-->${to}`);
}

// ---------- Parse & collect ----------
const files = await glob(SRC_GLOB, {
  ignore: ['**/node_modules/**', '**/android/**', '**/ios/**'],
});

for (const file of files) {
  let code;
  try { code = fs.readFileSync(file, 'utf8'); } catch { continue; }

  let ast;
  try {
    ast = parse(code, {
      sourceType: 'module',
      sourceFilename: file,
      plugins: [
        'jsx','typescript',
        'classProperties','decorators-legacy',
        'objectRestSpread','dynamicImport',
        'optionalChaining','nullishCoalescingOperator',
        'topLevelAwait',
      ],
    });
  } catch {
    continue;
  }

  const localNavigatorVars = new Set();

  traverse(ast, {
    VariableDeclarator(p) {
      const id = p.node.id;
      const init = p.node.init;
      if (!id || id.type !== 'Identifier' || !init) return;

      const isNavFactory =
        init.type === 'CallExpression' &&
        (
          (init.callee.type === 'Identifier' && navigatorFactoryNames.has(init.callee.name)) ||
          (init.callee.type === 'MemberExpression' && init.callee.property && navigatorFactoryNames.has(init.callee.property.name))
        );

      if (isNavFactory) {
        localNavigatorVars.add(id.name);
        let t = 'Navigator';
        const callee = init.callee;
        const name = callee.type === 'Identifier'
          ? callee.name
          : (callee.property?.name || 'createNavigator');
        if (name.includes('Stack')) t = 'Stack';
        else if (name.includes('Tab')) t = 'Tab';
        else if (name.includes('Drawer')) t = 'Drawer';
        upsertNavigator(id.name, t, file);
      }
    },

    JSXElement(p) {
      const opening = p.node.openingElement;
      const tagName = getJSXName(opening.name);
      if (!tagName) return;

      if (tagName.endsWith('.Navigator')) {
        const navVar = tagName.split('.')[0];
        if (!localNavigatorVars.has(navVar)) return;

        upsertNavigator(navVar, project.navigators.get(navVar)?.type, file);

        const children = p.node.children || [];
        for (const ch of children) {
          if (ch.type !== 'JSXElement') continue;
          const childName = getJSXName(ch.openingElement.name);
          if (!childName || !childName.endsWith('.Screen')) continue;

          const nameAttr = firstAttr(ch, ['name']);
          const screenName = nameAttr ? attrValueString(nameAttr) : null;
          if (screenName) addScreen(navVar, screenName);

          const compAttr = firstAttr(ch, ['component']);
          const compVal = compAttr ? attrValueString(compAttr) : null;
          if (compVal && /^[A-Z].*Navigator$/.test(compVal)) {
            addScreen(navVar, `${screenName || compVal} (nested)`);
          }
        }
      }
    },
  });

  // Second pass: try to infer "from" for navigate() calls
  traverse(ast, {
    CallExpression(p) {
      const callee = p.node.callee;
      if (
        callee?.type === 'MemberExpression' &&
        callee.property?.type === 'Identifier' &&
        callee.property.name === 'navigate'
      ) {
        const args = p.node.arguments || [];
        if (!(args[0] && args[0].type === 'StringLiteral')) return;
        const target = args[0].value;

        let fromName = null;
        let curr = p.parentPath;
        while (curr && !fromName) {
          const n = curr.node;
          if (n.type === 'FunctionDeclaration' && n.id?.name) fromName = n.id.name;
          if (n.type === 'VariableDeclarator' && n.id?.type === 'Identifier') fromName = n.id.name;
          if (n.type === 'ClassDeclaration' && n.id?.name) fromName = n.id.name;
          curr = curr.parentPath;
        }
        addEdge(fromName || 'SomeScreen', target); // fallback if we cannot infer
      }
    }
  });
}

// ---------- Emit Mermaid (with splitting) ----------
ensureDir(OUT_DIR);

// common header with high edge cap
function header() {
  return [
    `%%{init: {"maxEdges": ${MAX_EDGES_INIT}}}%%`,
    'flowchart TD',
    '  %% Auto-generated React Navigation graph',
  ].join('\n');
}

// nodes (subgraphs) appear in every file so each chunk is self-contained
function emitNodes() {
  const lines = [];
  for (const [nav, meta] of project.navigators.entries()) {
    const label = `${meta.type || 'Navigator'}:${nav}`;
    const groupId = `subgraph_${sanitizeId(nav)}`;
    lines.push(`  subgraph ${groupId}["${label}"]`);
    for (const s of meta.screens) {
      const nodeId = sanitizeId(`${nav}_${s}`);
      lines.push(`    ${nodeId}["${s}"]`);
    }
    lines.push('  end');
  }
  return lines.join('\n');
}

// split edges into chunks
const allEdges = Array.from(project.edges);
const chunks = [];
for (let i = 0; i < allEdges.length; i += EDGE_LIMIT_PER_FILE) {
  chunks.push(allEdges.slice(i, i + EDGE_LIMIT_PER_FILE));
}

const nodeSection = emitNodes();
chunks.forEach((edges, idx) => {
  const outPath = path.join(OUT_DIR, `${BASENAME}_${idx + 1}.mmd`);
  const lines = [header(), nodeSection];
  for (const e of edges) {
    const [from, to] = e.split('-->');
    lines.push(`  ${sanitizeId(from)} --> ${sanitizeId(to)}`);
  }
  writeText(outPath, lines.join('\n') + '\n');
  // eslint-disable-next-line no-console
  console.log(`Wrote ${outPath} (edges: ${edges.length})`);
});

// also write a tiny index file that links the parts
const indexLines = ['# Navigation Graph (split)', ''];
chunks.forEach((_, idx) => {
  indexLines.push(`- \`${BASENAME}_${idx + 1}.mmd\``);
});
writeText(path.join(OUT_DIR, `${BASENAME}_INDEX.md`), indexLines.join('\n') + '\n');