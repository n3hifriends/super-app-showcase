#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import glob from 'glob';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';

const SRC_GLOB = process.argv[2] || 'src/**/*.{js,jsx,ts,tsx}';

// --- Utilities ---
const readFile = (p) => fs.readFileSync(p, 'utf8');

function parseCode(code, filename) {
  return parse(code, {
    sourceType: 'module',
    sourceFilename: filename,
    plugins: [
      'jsx',
      'typescript',
      // Allow modern syntax just in case:
      'classProperties',
      'decorators-legacy',
      'objectRestSpread',
      'dynamicImport',
      'optionalChaining',
      'nullishCoalescingOperator',
      'topLevelAwait',
    ],
  });
}

// Recognize e.g. const Stack = createNativeStackNavigator();
const navigatorFactoryNames = new Set([
  'createNativeStackNavigator',
  'createStackNavigator',
  'createBottomTabNavigator',
  'createMaterialTopTabNavigator',
  'createDrawerNavigator',
]);

// JSX tags like: <Stack.Navigator>, <Tab.Navigator>, <Drawer.Navigator>, <Stack.Screen>
function getJSXName(node) {
  if (!node) return null;
  if (node.type === 'JSXIdentifier') return node.name;
  if (node.type === 'JSXMemberExpression') {
    const left = getJSXName(node.object);
    const right = getJSXName(node.property);
    return left && right ? `${left}.${right}` : null;
  }
  return null;
}

function attrValueString(attr) {
  if (!attr || !attr.value) return null;
  if (attr.value.type === 'StringLiteral') return attr.value.value;
  if (attr.value.type === 'JSXExpressionContainer') {
    const expr = attr.value.expression;
    if (expr.type === 'StringLiteral') return expr.value;
    if (expr.type === 'Identifier') return expr.name; // component identifier fallback
    if (expr.type === 'MemberExpression') {
      // e.g., SomeNavigator
      if (expr.property && expr.property.name) return expr.property.name;
    }
  }
  return null;
}

function firstAttr(node, names) {
  for (const a of node.openingElement.attributes || []) {
    if (a.type === 'JSXAttribute' && names.includes(a.name.name)) return a;
  }
  return null;
}

const project = {
  navigators: new Map(), // navVarName -> { type: 'Stack'|'Tab'|'Drawer', screens: Set<screenName>, file }
  screensInNavigators: {}, // navigator -> Set of screen names
  edges: new Set(), // "A-->B"
};

function upsertNavigator(nvName, type, file) {
  if (!project.navigators.has(nvName)) {
    project.navigators.set(nvName, { type, screens: new Set(), file });
  } else {
    const obj = project.navigators.get(nvName);
    if (!obj.type && type) obj.type = type;
    if (!obj.file) obj.file = file;
  }
}

function addEdge(from, to) {
  if (!from || !to || from === to) return;
  project.edges.add(`${from}-->${to}`);
}

function addScreenToNav(nav, screen) {
  if (!nav || !screen) return;
  upsertNavigator(nav);
  project.navigators.get(nav).screens.add(screen);
}

// --- Scan files ---
const files = glob.sync(SRC_GLOB, { ignore: ['**/node_modules/**', '**/android/**', '**/ios/**'] });

for (const file of files) {
  let code;
  try { code = readFile(file); } catch { continue; }
  let ast;
  try { ast = parseCode(code, file); } catch { continue; }

  // Track local identifiers bound to a navigator factory result
  // e.g., const Stack = createNativeStackNavigator();
  const localNavigatorVars = new Set();

  traverse(ast, {
    VariableDeclarator(p) {
      const id = p.node.id;
      const init = p.node.init;
      if (!id || id.type !== 'Identifier' || !init) return;
      if (
        init.type === 'CallExpression' &&
        ((init.callee.type === 'Identifier' && navigatorFactoryNames.has(init.callee.name)) ||
         (init.callee.type === 'MemberExpression' && init.callee.property && navigatorFactoryNames.has(init.callee.property.name)))
      ) {
        localNavigatorVars.add(id.name);
        // infer type from callee:
        let t = 'Navigator';
        const callee = init.callee;
        const name = callee.type === 'Identifier'
          ? callee.name
          : (callee.property?.name || 'createNavigator');
        if (name.includes('Stack')) t = 'Stack';
        else if (name.includes('Tab')) t = 'Tab';
        else if (name.includes('Drawer')) t = 'Drawer';
        upsertNavigator(id.name, t, file);
      }
    },

    // Find <Stack.Navigator> trees and <Stack.Screen name="X" />
    JSXElement(p) {
      const opening = p.node.openingElement;
      const tagName = getJSXName(opening.name); // e.g., "Stack.Navigator" or "Stack.Screen"
      if (!tagName) return;

      // Only care about X.Navigator
      if (tagName.endsWith('.Navigator')) {
        const navVar = tagName.split('.')[0]; // "Stack"
        if (localNavigatorVars.has(navVar)) {
          upsertNavigator(navVar, project.navigators.get(navVar)?.type, file);

          // collect all immediate child Screens
          const children = p.node.children || [];
          for (const ch of children) {
            if (ch.type !== 'JSXElement') continue;
            const childName = getJSXName(ch.openingElement.name);
            if (!childName || !childName.endsWith('.Screen')) continue;

            const nameAttr = firstAttr(ch, ['name']);
            const screenName = nameAttr ? attrValueString(nameAttr) : null;
            if (screenName) addScreenToNav(navVar, screenName);

            // Also check for component prop that might itself be a Navigator component
            const compAttr = firstAttr(ch, ['component']);
            const compVal = compAttr ? attrValueString(compAttr) : null;
            // If component looks like a navigator component identifier, keep track as a "nested" screen label
            if (compVal && /^[A-Z].*Navigator$/.test(compVal)) {
              addScreenToNav(navVar, `${screenName || compVal} (nested)`);
            }
          }
        }
      }
    },

    // Find navigation.navigate('ScreenName') calls
    CallExpression(p) {
      const callee = p.node.callee;
      if (
        callee &&
        callee.type === 'MemberExpression' &&
        callee.property &&
        callee.property.type === 'Identifier' &&
        callee.property.name === 'navigate'
      ) {
        const args = p.node.arguments || [];
        if (args.length > 0 && args[0].type === 'StringLiteral') {
          const target = args[0].value;
          // We don't always know "from", so we will add generic edge ScreenX-->ScreenY later
          // but here we at least register target in a pool
          addEdge('SomeScreen', target); // placeholder; weâ€™ll refine below if possible
        }
      }
    },
  });

  // OPTIONAL refinement (best-effort): infer "from" screen by nearest function/Component name
  traverse(ast, {
    CallExpression(p) {
      const callee = p.node.callee;
      if (
        callee?.type === 'MemberExpression' &&
        callee.property?.type === 'Identifier' &&
        callee.property.name === 'navigate'
      ) {
        const args = p.node.arguments || [];
        if (!(args[0] && args[0].type === 'StringLiteral')) return;
        const target = args[0].value;

        // Walk up to find the nearest function or variable name (component-ish)
        let fromName = null;
        let curr = p.parentPath;
        while (curr && !fromName) {
          const n = curr.node;
          if (n.type === 'FunctionDeclaration' && n.id?.name) fromName = n.id.name;
          if (n.type === 'VariableDeclarator' && n.id?.type === 'Identifier') fromName = n.id.name;
          if (n.type === 'ClassDeclaration' && n.id?.name) fromName = n.id.name;
          curr = curr.parentPath;
        }
        if (fromName) addEdge(fromName, target);
      }
    }
  });
}

// --- Build Mermaid ---
const lines = [];
lines.push('```mermaid');
lines.push('flowchart TD');
lines.push('  %% Auto-generated React Navigation graph');

for (const [nav, meta] of project.navigators.entries()) {
  const label = `${meta.type || 'Navigator'}:${nav}`;
  const groupId = `subgraph_${nav}`;
  lines.push(`  subgraph ${groupId}["${label}"]`);
  for (const s of meta.screens) {
    const nodeId = `${nav}_${s}`.replace(/[^a-zA-Z0-9_]/g, '_');
    lines.push(`    ${nodeId}["${s}"]`);
  }
  lines.push('  end');
}

// Edges inferred from navigate() calls (best-effort)
for (const e of project.edges) {
  const [from, to] = e.split('-->');
  const fromId = from.replace(/[^a-zA-Z0-9_]/g, '_');
  const toId = to.replace(/[^a-zA-Z0-9_]/g, '_');
  lines.push(`  ${fromId} --> ${toId}`);
}

lines.push('```');
console.log(lines.join('\n'));